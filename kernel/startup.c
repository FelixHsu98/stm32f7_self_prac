#include "type.h"
#include "memlayout.h"
#include "defs.h"
#include "uart.h"
#include "proc.h"
#include "arm.h"

extern int _sdata, _edata, _sbss, _ebss, _sidata;

extern void _estack(); // Defined in link.ld

volatile uint32 _sticks = 0;

extern int main(void);

void
timerinit(void)
{
  *(SYS_CSR) |= (0x00000007); // enable CLKSOURCE, TICKINT, ENABLE
  // default systick is generated by HSI RC oscillator with 16MHz
  // at here, set RVR to 1ms. That means _systick_handler will
  // be triggered every 1ms
  *(SYS_RVR) = (FREQ / 1000) - 1;
  *(SYS_CVR) = 0;
}

void
prioinit(void)
{
  *(SYS_SHPR3) = (PENDSVPRI);
}

// Startup code
__attribute__((naked, noreturn)) void _reset(void)
{
  for(int *dst = &_sbss; dst < &_ebss; dst++) *dst = 0;

  for(int *dst = &_sdata, *src = &_sidata; dst < &_edata; dst++, src++)
    *dst = *src;
 
  prioinit(); 
  uartinit((struct uart *)USART3, 115200);
  main();
  for(;;);
}

void _hardfault_handler(void)
{
  while(1);
}

void _NMI_handler(void)  __attribute((weak, alias("_hardfault_handler")));
void _mem_manage_handler(void)  __attribute((weak, alias("_hardfault_handler")));
void _busfault_handler(void)  __attribute((weak, alias("_hardfault_handler")));
void _usagefault_handler(void)  __attribute((weak, alias("_hardfault_handler")));

void _pendsv_handler(void)
{
  struct proc *p = myproc();
  p->context.sp = (uint32)r_psp();
  yield();
  w_psp(p->context.sp);
}

void _systick_handler(void)
{
  _sticks++;
 
  *(SYS_ICSR) |= ((_sticks % 100) == 0) ? (PENDSVSET) : 0; // trigger PendSV handler for context switch
  
}

extern void _svc_handler(void);

// 16 standard and 98 STM32-specific handlers
__attribute__((section(".vectors"))) void (*const tab[16+98])(void)={
  _estack,		// 0
  _reset,		// 1
  _NMI_handler,		// 2
  _hardfault_handler,	// 3
  _mem_manage_handler,	// 4
  _busfault_handler,	// 5
  _usagefault_handler,	// 6
  0, 0, 0, 0,		// 7-10 reserve
  _svc_handler,		// 11
  0, 0,			// 12-13 reserve
  _pendsv_handler,	// 14 
  _systick_handler	// 15
};
